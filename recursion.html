<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Recursion practice</title>
</head>
<body>
	<script>
	//FUNCTION THAT TESTS IF A NUMBER IS EVEN
		function isEven(n) {
			if (n === 0) {
				return true;
			} else if (n === 1) {
				return false;
			} else if (n < 0) {
				return isEven(-n); //this turns a negative number into a positive and runs until n === 1 || 0
			} else {
				return isEven(n - 2); //this is recursive because it runs until n === 1 || 0
			}
		}
		//TESTS
		console.log(isEven(50));
		console.log(isEven(75));
		console.log(isEven(-3));

//FUNCTION THAT TESTS IS A NUMBER IS ODD
		function isOdd(n) {
			if (n === 0) {
				return false;
			} else if (n === 1) {
				return true;
			} else if (n < 0) {
				return isOdd(-n);
			} else {
				return isOdd(n -2);
			}
		}
		//TESTS
		console.log(isOdd(50));
		console.log(isOdd(75));
		console.log(isOdd(-3));

//FUNCTION THAT DOES FACTORIALS
	/*FOR SAKE OF CLARITY: factorials are every number between 1 and that number multipled
		--> 5! = 5*4*3*2*1
				In the factorial problem, the larger problem is multiplying all the numbers between the given number (n) and 1.
					i.e. 5! = 5*4*3*2*1

				Because factorials are doing the same thing over and over again until you get the desired result, it could be done iteratively with looping (explaination in comments on side)--> 
					function factorialLoop(n) {
						var result = 1;                //this is the smallest factorial output you'll get (0! === 1);
						var count;					   //need to declare a new var count to keep track of count
						for (count = n; count > 1; count--) { 
													   //basically says: start the count, at the given 
													   number, n, continue looping while count is greater than one, iterating by subracting 1 from count at each loop.
							result *= count;           //says that the result is equal to the result at each 
							                           iteration multipled by the count.
							                           //for example: if n = 5: 
														the first time around, result = 1; count = 5;
														∴ result = 1 * 5
														  result = 5;
														next:
														  result = 5; count = 4;
														  result = 5 * 4;
														  result = 20;
														next:
														  result = 20; count = 3;
														  result = 60;
														next:
														  result = 60; count = 2; //This will be the last iteration 
														  							because it is the last time the count will be > 1
														  result = 120;

														  ∴ the result is returned == 120
						}
						return result;
					}
					<-- however, this means it can also be done recursively, less efficiently (because you have to call the function for each iteration rather than storing the value at each iteration), more elegantly.
					In ALL recursive functions, you should look for a base case, the statement that, usually within a conditional statement (i.e. 'if' statement), will stop the recursion. 

					This means that a BASE CASE is going to the the most basic execution, and thus, the last execution of the rule you are trying to implement.

				To find the BASE CASE (the case in which the recursion stops), look to simplify the bigger problem into the simplest terms. For the factorial problem it is broken down like so:
					5! = 5 * 4 * 3 * 2 * 1; 

					4!= 4 * 3 * 2 * 1;

					3! = 3* 2 * 1;

					2! = 2 * 1;

				In the simplest example, 2!, this simply means 2 * 1, the multiplication of two numbers. In terms of variables, this can be denoted as (a*b). ∴ breaking up this larger problem into a smaller BASE problem, this is just multiplying two numbers.

				In the above explanation, we could (technically) split any factorial into the multiplication of two numbers (a * b):
					5! = 5 * (4 * 3 * 2 * 1);
						where 5 = a; (4 * 3 * 2 * 1) = b;
					more simply/clearly put:
					   = 5 * (24);
					   = 120

					4! = 4 * (3 * 2 * 1);
						where 4 = a; (3 * 2 * 1) = b;
					more simply/clearly put:
					   = 4 * (6);
					   = 24;

					3! = 3 * (2 * 1);
						where 3 = a; (2 * 1) = b;
					more simply/clearly put:
					   = 3 * (2);
					   = 6;

					2! = 2 * (1);
						where 2 = a; (1) = b;
					   = 2;

					As you can see, given the BASE CASE in terms of (a * b) there is a pattern with the b values here: 
						The b values are equal to the product of each number between 1 and one less the original given number (n);
						∴ For the factorial of a given number, n, the factorial is equal to that value (n) multiplied by each number between one less than that number (n-1) and 1.
							In simpler terms, the factorial of a given number is equal to a given number (n) multipled by the factorial of (n - 1) where
									a = n;
									b = ((n - 1)!);
								Therefore, n! = n * ((n - 1)!);


	*/
	function factorial(n) {
		if (n === 0) {
			return 1; //This is because 0! is equal to 1
		} else if (n < 0) {
			console.log("Number must be positive to run a factorial!");
			return; //this is an example of a termination condition, it will explicitly stop the recursion
		} else {
			return n * factorial(n -1); //explanation above!
		}
	}

	//TESTS
	console.log(factorial(2));
	// --> 2;
	console.log(factorial(5));
	// --> 120;
	console.log(factorial(10));
	// --> 3628800;
	console.log(factorial(100));
	// --> 9.332622e+157;

	</script>
</body>
</html>